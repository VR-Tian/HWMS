云计算：
服务器的使用率
比喻：过去，农村每个家庭要打一口井打水喝。现代，每户家庭连接水厂提供的自来水

引出.NetCore配套的开发框架是微软来云计算的市场占有率


.NetCore优点：
1做到模块化运行和部署（不依赖任何组件，每个发布的程序都有它的版本，不会造成依赖组件更新的影响）
2跨平台

缺点：
1无法对.NetFramework的旧技术的支持（比如WCF，ASP.NETWebForm，WF）



关于有些项目创建会出现.Net（Framework）、.NetStandard、.NetCore、Xamaim?，它们的区别和关系：
.NetStandard>=.NetCore + .Net（Framework）
.NetStandard是其他框架的基层，对基础类型的抽象定义（规范，没有具体实现），在其他框架上进行实现（通过创建一个Standard的库实现一个打印被不同框架引用所呈现的DLL位置）
（反编译工具）
关于使用.NetStandard实现的类库版本被其他框架引用的兼容性问题

工具：windows sanbox 微软系统沙盒， WSL Linux系统沙盒
.NetCore（.NET5）发布模式（可选项的）


关于NuGet的使用规范引用开源的组件
1、关于框架版本兼容问题
2、使用方式(CLI、包管理器)

===================================================================
异步编程
⭐异步!=多线程
作用：提高系统请求吞吐量（线程池排队），服务更多请求资源服务
异步不会加快对原有单个请求处理的速度，处理时间还是不变。

.Net异步：
使用Task（具有返回泛型）来修饰需要异步的函数
await 等待调用异步函数的返回再执行下一步（否则继续执行，使用WriteLine等函数除外）
async 修饰声明当前需要调用异步的函数内有阻塞操作，
即是为了告诉调用者是异步函数(一旦内部使用await关键字去等待另一个异步函数，则此函数则必须使用此修饰符。若主函数内不能被修饰，则直接获取异步结果)
实现原理：
编译后逻辑被拆分成多个顺序块，通过状态机模式进行“等待”（goto语法）

⭐async和多线程的关系：
即说同步操作和异步操作的区别，封装函数的方式

多个异步任务的并行执行实现：
WhenAll

⭐关于线程进行重拾过程注意事项：
1勿使用Thread.Sleep方式进行等待操作，这个API是针对对象是主线程
Task.Delay 针对是异步中使用的线程对象。
2停止异步操作实现（终止任务）：
API:CancellactionToken（结构体）。设置超时策略来进行终止任务。

关于yield使用场景：
可以使得代码流水平方向执行（演示通过返回集合的效果）

==================================================================

Linq语法由来：
基础：1委托->2lambda->3Linq(语言集成查询)
1委托：把函数当成一种基本类型的进行声明并传递调用，即委托是函数声明变量的类型（与class同级，修饰符为delegate）。
2lambda：是匿名函数的升级语法糖，主要为了解决在声明委托变量时不需要显示声明函数。实现用“=> ”
3Linq：是框架提供运算一种引擎，是实现IEnumable的拓展方法。

Linq写法有两种形式：查询语法，方法语法

场景：根据一个字符串统计其内容出现高于2次频率的字母和出现次数
实现Where过程：

=====================================================================
⭐IOC：控制反转。实现方式：1服务定位器。2DI：依赖注入
两者的关系：DI是具体实现，IOC是具体实现的服务定位器的容器(不严谨)

作用：简化各个模块层次之间的引用关系，降低模块之间耦合度。
基础：面向接口编程，里氏转换

DI的使用涉及概念：
1提供服务的对象：服务(注册)类型(一般是接口类型)，实现(具体)类型
2注册服务的方式
3管理服务的容器
4获取服务的方式
5服务生存的周期:
Transient瞬时（每次获取实现类型都一个新对象）、
Scoped范围（指定生存范围，比如ASP.NETCore在一次请求响应过程中是同一个对象,在using语法中使用范围同一个对象）、
Singleton单例（在生命周期中获取实现类型同一个对象） 
6依赖服务传染性：当实现类型中存在另一个服务类型需要被注册，就会迭代到最后服务类型的实现类型，从而形成一种依赖关系


关于ASP.NET Core中直接添加服务的实现过程：
不需要通过显示的注册服务类型和对应的实现类型，通过拓展方法的进行对每个服务对象以方法形式调用声明。（把服务的实现类型又扔回给调用者去实现）




⭐.Net Core的配置，使用DI注入形式的动态读取配置项。
关于获取“动态”获取配置项的模式：
1、IOptionsSnapshot：
2、IOptionsMonitor：


关于配置项的存储来源：
1、XML、JSON等文本文件形式
2、命令行形式（入参扁平化的构造）
3、环境变量
4、实现从数据库读取

引出需求：
集群服务器的系统通过配置服务器来读取配置信息，若某个集群服务器需要单独获取指定配置，如何解耦
思路：配置来源约定优先级别，通过级别进行覆盖

.Net Core的配置机制已经实现关于多个配置源覆盖问题（优先性取决于在添加配置项顺序）


⭐.Net Core Logging 日志
通过配置模式输出格式和输出源
搭配Nlog输出到文本文件（滚动日志模式的实现）

SeriLog（在集群情况下，配置比Nlog简单易用）：
1异常信息的结构化（利于对日志的查询排查）
2集中化日志（集群或分布式情况下日志如何汇总起来形成报表数据)：根据Exceptionless提供的SeriLog插件写入到本地搭建的日志服务器（SelfHost）

⭐EF Core
ORM:程序与数据库的解耦，为了更好的利用面向对象思想，对数据库的设计进行透明化，让程序开发人员不再过多关注数据库的读写SQL操作。
模型驱动：
1迁移Migrations：不再需要手动在数据库创建表结构。
使用EF Core的前提是ADO.NET Core提供支持，并且能被EF Core进行反映射操作（或者自己根据数据库实现EF Core的Provider）

SQL索引：
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
索引：按照特定顺序的一种存储数据结构
左小<X<右大排序；key-value 存储结构
二叉树：无法满足自增字段索引检索。（优化：增加树节点个数，让检索次数减少）
二叉树平衡（红黑树） ：随索引数量增加根节点高度逐渐增加（优化：水平方向对索引元素存放更多根节点，减少高度，B树）
B树：对于范围查询需要回表（优化：相邻的叶结点相互保存对方存储位置，从左到右依次递增排序，B+树）
B+树：优点通过冗余索引降低树的层次，提高查询速度 

哈希结构：数组+链表（不支持范围查询）
使用主键自增：对已存在顺序的数据结构一种保护，若破坏了树结构可能会导致树层次增加（uuid类型的主键）

聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个
聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续
聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序
非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.
索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点（回表查询指向主键索引）






















